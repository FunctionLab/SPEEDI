---
title: "SPEEDI (Single-cell Pipeline for End-to-End Data Integration)"
author:
- name: Yuan Wang
  affiliation: Princeton University
- name: William Thistlethwaite
  affiliation: Princeton University
  email: wat2@princeton.edu
package: SPEEDI
output:
  BiocStyle::html_document
abstract: |
  To facilitate single-cell omics analyses and improve reproducibility, we present SPEEDI, a fully automated end-to-end single-cell data science framework. SPEEDI introduces a data-driven batch inference method and transforms often heterogeneous data matrices obtained from different samples into a uniformly cell-type annotated and integrated dataset. By eliminating manual parameter selection, developing batch identification, providing full automation, and performing initial interpretive analyses, SPEEDI improves reproducibility and democratizes biological discovery using single-cell datasets.
vignette: |
  %\VignetteIndexEntry{SPEEDI (Single-cell Pipeline for End-to-End Data Integration)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE
)
```


# Citation

The SPEEDI manuscript is currently under preparation.

# Installation and Loading

To begin, we install the SPEEDI package and its dependencies.

```{r installation, eval=FALSE}
# Install necessary packages
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
devtools::install_github('FunctionLab/SPEEDI', repos = BiocManager::repositories())
```

We then load the SPEEDI package.

```{r loading, message=FALSE}
# Load SPEEDI
library(SPEEDI)
```

# Quick Start

After loading SPEEDI, the fastest way to begin using the pipeline is through the `run_SPEEDI()` function. In the provided code snippet, we show a brief illustration with some example inputs, but you should read the documentation for the function (i.e., `?run_SPEEDI`) and look at our complete example analysis below to learn more.

```{r quick_start, eval = FALSE}
# Example parameters for run_SPEEDI - note that some optional parameters were not used
# To see other options for reference_tissue, data_type, and species, look at ?run_SPEEDI
reference_tissue <- "PBMC"
data_type <- "RNA"
species <- "human"
# input_dir points to where input data is stored
# Note that input data should be FILTERED H5 or MEX (matrix.mtx.gz / barcodes.tsv.gz / features.tsv.gz) files
# generated by Cell Ranger
input_dir <- "~/test_input"
# output_dir points to where output data will be stored
output_dir <- "~/test_output"
# Run SPEEDI pipeline (not run)
run_SPEEDI(reference_tissue = reference_tissue, data_type = data_type, species = species, input_dir = input_dir,  
           output_dir = output_dir)
```

# Example Analysis for scRNA-seq (PBMC, COVID)

## Introduction

Our example scRNA-seq data come from the publication [Differential chromatin accessibility in peripheral blood mononuclear cells underlies COVID-19 disease severity prior to seroconversion](https://pubmed.ncbi.nlm.nih.gov/35810186/). We integrate data from 5 healthy controls and 4 severe COVID patients, and we also perform some preliminary downstream analyses (differential expression analysis and functional module discovery).

Importantly, the input data for our analysis are available on [GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE206283). You can download the files using `wget` as in the code snippet below:

```{sh, eval=FALSE}
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249272/suppl/GSM6249272_scRNA_2209_filtered_feature_bc_matrix.tar.gz
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249273/suppl/GSM6249273_scRNA_2211_filtered_feature_bc_matrix.tar.gz
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249274/suppl/GSM6249274_scRNA_2213_filtered_feature_bc_matrix.tar.gz
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249275/suppl/GSM6249275_scRNA_2224_filtered_feature_bc_matrix.tar.gz
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249276/suppl/GSM6249276_scRNA_2227_filtered_feature_bc_matrix.tar.gz
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249252/suppl/GSM6249252_scRNA_34-7_filtered_feature_bc_matrix.tar.gz
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249254/suppl/GSM6249254_scRNA_39-7_filtered_feature_bc_matrix.tar.gz
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249257/suppl/GSM6249257_scRNA_41-7_filtered_feature_bc_matrix.tar.gz
wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM6249nnn/GSM6249270/suppl/GSM6249270_scRNA_145-7_filtered_feature_bc_matrix.tar.gz
```

We can then unarchive these files and rename the resulting folders so that the names are cleaner:

```{sh, eval=FALSE}
for i in *.tar.gz; do tar -xvf $i; done
for folder in *_filtered_feature_bc_matrix; do
    new_folder="${folder%_filtered_feature_bc_matrix}"
    mv "$folder" "$new_folder"
done
```

Within each folder, we have filtered data generated by Cell Ranger in the [MEX format](https://kb.10xgenomics.com/hc/en-us/articles/115000794686-How-is-the-MEX-format-used-for-the-gene-barcode-matrices). SPEEDI also works with [H5 format](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/advanced/h5_matrices) files. If working with MEX files, sample data should always follow the standard naming convention (three files with names `barcodes.tsv.gz`, `features.tsv.gz`, and `matrix.mtx.gz`). If working with H5 files, sample data file names should always end with `filtered_feature_bc_matrix.h5`. For example, `filtered_feature_bc_matrix.h5` and `Sample_1_filtered_feature_bc_matrix.h5` would both be fine, but `filtered_matrix.h5` would result in an error.

**IMPORTANT**: SPEEDI expects data that have been [filtered](https://kb.10xgenomics.com/hc/en-us/articles/360001892491-What-is-the-difference-between-the-filtered-and-raw-gene-barcode-matrix-) using Cell Ranger or some other similar process.

## Step 0: Set Up SPEEDI

After downloading our input data, we are ready to begin using the SPEEDI pipeline. We could use the `run_SPEEDI()` function to run the entire pipeline, but we will go through the pipeline step-by-step for clarity.

First, we'll go over the different parameters for SPEEDI. We highly recommend that you read the `run_SPEEDI()` function documentation to see all possible values for each parameter.

We'll begin with the parameters that we provide values for in this analysis:

* `reference_tissue`: Reference tissue type (used to map cell types via reference). Here, we choose `PBMC_full` (full explanation below).
* `data_type`: Type of data being processed. Here, we choose `RNA`.
* `species`: Species being analyzed. Here, we choose `human`.
* `input_dir`: Path to directory where input data are located. Here, we choose `input/`.
* `reference_dir`: Path to directory where reference will be downloaded by `LoadReferenceSPEEDI()` if necessary. Here, we choose `references/`.
* `output_dir`: Path to directory where output will be saved. Here, we choose `output/`.
* `metadata_df`: Data frame that contains metadata about our samples. Its value will declared in the code snippet below.

There are two different PBMC reference tissue types in SPEEDI: `PBMC` and `PBMC_full`. The former uses a `SeuratData` reference and `Azimuth` to map cell types, while the latter downloads a more detailed, quite large (~8 GB) PBMC reference for cell type mapping. To get the best possible mapping, we choose the latter. Importantly, SPEEDI loads this reference into memory during processing, so you should use `PBMC` unless you have sufficient memory to load the `PBMC_full` reference.

Our other parameters will use the default values:

* `reference_file_name`: Base name of custom reference file. Because we're not using a custom reference file, we leave this at its default value (`NULL`).
* `reference_cell_type_attribute`: If using a Seurat reference object, this parameter captures where the cell type information is stored. We leave this at its default value (`"celltype.l2"`).
* `analysis_name`: Name used to create subdirectory in `output_dir` for current analysis run. We'll let SPEEDI set this for us, so we'll leave it at its default value (`NULL`).
* `sample_id_list`: Vector of sample names (optional - if not provided, will select all samples found recursively in `input_dir`). Because we're analyzing all of the samples that we downloaded (and not a subset), we leave this at its default value (`NULL`).
* `sample_file_paths`: Vector of sample file paths (optional - if not provided, will select all samples found recursively in `input_dir`). If this argument is used, `sample_id_list` is required and should be written in the same order as the sample file paths. Because we're analyzing all of the samples that we downloaded (and not a subset), we leave this at its default value (`NULL`).
* `record_doublets`: Boolean flag to indicate whether we will record doublets in the data (using the `scDblFinder` package). We leave this at its default value (`FALSE`).

```{r set_up_variables_rna}
reference_tissue <- "PBMC_full"
data_type <- "RNA"
species <- "human"
input_dir <- "input/"
reference_dir <- "references/"
output_dir <- "output/"
# Here, we set up our (very simple) metadata data frame
metadata_df <- data.frame("disease" = c("COVID", "COVID", "COVID", "COVID", 
                                        "healthy", "healthy", "healthy", "healthy", "healthy"))
rownames(metadata_df) <- c("scRNA_34-7", "scRNA_39-7", "scRNA_41-7", "scRNA_145-7", 
                           "scRNA_2209", "scRNA_2211", "scRNA_2213", "scRNA_2224", "scRNA_2227")
```

To complete our setup, we set a random seed using `set.seed()` to ensure reproducibility and then use the `initialize_SPEEDI()` function. While this function isn't strictly necessary for using SPEEDI, it will help make sure that all variables are set properly and will create a log file for SPEEDI.

```{r initialize_speedi_rna}
# Note that we use get_speedi_seed() to get the global seed used by SPEEDI for tasks like SCTransform normalization, UMAP generation etc.
# If you want to set a different global seed for SPEEDI, you can use the set_speedi_seed() function
set.seed(get_speedi_seed())
SPEEDI_variables <- initialize_SPEEDI(reference_tissue, data_type, species, 
                                      input_dir, reference_dir, output_dir, metadata_df)
```

After running `initialize_SPEEDI()`, all of the corrected variable values will be stored in the `SPEEDI_variables` list. These variables include everything highlighted above as well as a few new ones:

* `RNA_output_dir`: Output directory for RNA analyses (will contain all analysis output for this example)
* `ATAC_output_dir`: Output directory for ATAC analyses (not relevant for this example)
* `log_file_path`: File name associated with log file
* `old_wd`: ATAC analyses require our working directory be updated to `ATAC_output_dir`, so we save the previous working directory in `old_wd` (not relevant for this example)

To refer to a given variable, use list notation (e.g., the corrected `input_dir` is stored in `SPEEDI_variables$input_dir`).

Note the directory structures below:

```{r directory_structures_rna}
# output_dir now includes a subdirectory for our specific analysis
# This directory contains our log file
SPEEDI_variables$output_dir
# RNA_output_dir is a subdirectory of our new output_dir
SPEEDI_variables$RNA_output_dir
```

## Step 1: Load Reference

Before we begin processing the input data, we first load our `PBMC` reference. Because we're using `PBMC_full` as our `reference_tissue` value, SPEEDI will automatically download the reference object (`pbmc_multimodal.h5seurat`) and save it in `reference_dir`. Note that we set `log_flag` to `TRUE` so that any messages are automatically recorded in our log file.

```{r load_reference_rna}
reference <- LoadReferenceSPEEDI(reference_tissue = SPEEDI_variables$reference_tissue, 
                                 reference_dir = SPEEDI_variables$reference_dir,
                                 species = SPEEDI_variables$species, log_flag = TRUE)
```

We can see that `reference` now stores a Seurat object:

```{r show_reference_rna}
reference
```

## Step 2: Read Input Data

Next, we will read in the input data (scRNA-seq) for processing using the `Read_RNA()` function. Sample data are processed in parallel and compiled into a single comprehensive expression matrix.

```{r read_data_rna}
all_sc_exp_matrices <- Read_RNA(input_dir = SPEEDI_variables$input_dir, log_flag = TRUE)
nrow(all_sc_exp_matrices)
ncol(all_sc_exp_matrices)
```

Our matrix contains 124692 barcodes and 32738 transcripts in total.

## Step 3: Filter Input Data

While our input data have been previously filtered by Cell Ranger, we still need to perform QC filtering (based on number of transcripts, number of genes, percentage of mitochondrial content, percentage of hemoglobin content, and percentage of ribosomal content). For each category, the `FilterRawData_RNA()` function automatically selects the QC threshold for each sample using the `kneedle` algorithm and the `quantile` function. In addition, the `FilterRawData_RNA()` function performs the following tasks:

* Creates pre-filtered QC plots for each category above (see below)
* Transforms the expression matrix into a `Seurat` object for easier downstream processing
* If `record_doublets` is set to `TRUE`, records information about doublets in the `Seurat` object

```{r filter_data_rna, fig.show='hide'}
sc_obj <- FilterRawData_RNA(all_sc_exp_matrices = all_sc_exp_matrices, species = SPEEDI_variables$species,
                           output_dir = SPEEDI_variables$RNA_output_dir, log_file_path = SPEEDI_variables$log_file_path, 
                           log_flag = TRUE)
# We can delete all_sc_exp_matrices because we're done with it
rm(all_sc_exp_matrices)
sc_obj
```

After QC filtering is complete, we see that 88870 barcodes and 21693 transcripts remain. You can always see the automatically chosen QC thresholds by looking at the log file (they may also be displayed in your standard R output depending on your environment). In addition, if you're interested in the quality of your samples before filtering, you can look at the automatically generated pre-filtering QC plots (found in `RNA_output_dir`). One example (for number of genes) is displayed below:

```{r, echo=FALSE, fig.cap="Pre-filtered QC plot for number of genes."}
knitr::include_graphics(paste0(SPEEDI_variables$RNA_output_dir, "pre-filtered_nFeature_violin_plot.png"))
```

## Step 4: Initial Processing

Now that the data have been filtered, we will normalize the data using `SCTransform()` (from `Seurat`). We regress against mitochondrial percentage (`percent.mt`), ribosomal percentage (`percent.rps` and `percent.rpl`), and hemoglobin percentage (`percent.hb`). We also calculate cell cycle scores and regress against the differences between S score and G2M score  (`CC.Difference`). Finally, we add metadata from `metadata_df` into our Seurat object.

```{r process_data_rna, results='hide', fig.show='hide'}
sc_obj <- InitialProcessing_RNA(sc_obj = sc_obj, species = SPEEDI_variables$species, 
                                output_dir = SPEEDI_variables$RNA_output_dir, metadata_df = SPEEDI_variables$metadata_df, 
                                log_flag = TRUE)
```

Looking at the UMAP generated from `InitialProcessing_RNA()`, we can see that the samples are not yet integrated:

```{r, echo=FALSE, fig.cap="UMAP of sample data before batch correction and integration."}
knitr::include_graphics(paste0(SPEEDI_variables$RNA_output_dir, "Before_Batch_Correction_RNA_UMAP_by_Sample.png"))
```

## Step 5: Inferring Data-Derived Batches

Next, we will use SPEEDI's data-derived batch inference method to determine sample batches in our data:

```{r infer_batches_rna, results='hide', fig.show='hide'}
sc_obj <- InferBatches(sc_obj = sc_obj, log_flag = TRUE)
```

In total, SPEEDI found 4 batches for our 9 samples:

```{r infer_batches_rna_results}
length(unique(sc_obj$batch))
```

## Step 6: Integrate Batches

After we have grouped our samples according to batch, we are ready to integrate by batch. We first normalize counts within each batch using `SCTransform()` and then use a selection of methods from `Seurat` (`SelectIntegrationFeatures()`, `PrepSCTIntegration()`, `FindIntegrationAnchors()`, and `IntegrateData()`) to integrate our data.

```{r integrate_batches_rna, results='hide', fig.show='hide'}
sc_obj <- IntegrateByBatch_RNA(sc_obj = sc_obj, log_flag = TRUE)
```

Note that we will now use the `integrated` assay for visualization (as opposed to the `SCT` assay) unless only one batch was found above:

```{r integrate_batches_rna_results}
sc_obj
```

## Step 7: Final Processing

We perform some final processing of our integrated data (scaling and preparing for differential expression) using the `VisualizeIntegration()` function.

```{r visualize_integration_rna, fig.show='hide'}
sc_obj <- VisualizeIntegration(sc_obj = sc_obj, output_dir = SPEEDI_variables$RNA_output_dir, log_flag = TRUE)
```

## Step 8: Map Cell Types

We are now ready to use our PBMC reference to map cell types onto our data. In this case, because we have a full `Seurat` reference object, our `MapCellTypes_RNA()` function uses the `Seurat` functions `FindMappingAnchors()` and `MapQuery()` to map cell types. For other built-in references, SPEEDI will use the `Azimuth` function `RunAzimuth()` to map cell types. Finally, SPEEDI runs a majority vote algorithm (`MajorityVote_RNA()`) to finalize cell types within each cluster.

```{r map_cell_types_rna, fig.show='hide'}
sc_obj <- MapCellTypes_RNA(sc_obj = sc_obj, reference = reference, output_dir = SPEEDI_variables$RNA_output_dir,
                           log_flag = TRUE)
# Table of final cell type predictions
knitr::kable(table(sc_obj$predicted_celltype_majority_vote), col.names = c("Cell Type", "Cell Count"))
```

The `MapCellTypes_RNA()` function prints UMAPs of our integrated sample data broken down by majority vote cell type, raw predicted cell type, cluster, and sample. Below, we print the sample UMAP and the majority vote cell type UMAP.

```{r, echo=FALSE, fig.cap="UMAP of sample data after batch correction and integration."}
knitr::include_graphics(paste0(SPEEDI_variables$RNA_output_dir, "Final_RNA_UMAP_by_Sample.png"))
```

Note that the samples are much better integrated versus our previous UMAP.

```{r, echo=FALSE, fig.cap="UMAP of cell types determined by majority vote."}
knitr::include_graphics(paste0(SPEEDI_variables$RNA_output_dir, "Final_RNA_UMAP_by_Majority_Vote_Cell_Type.png"))
```

Importantly, if the cells in a given cluster have an even mix of assigned cell types, the majority vote algorithm may not be able to determine an overall cell type for the cluster. We mark these clusters as "Undetermined". To better understand these Undetermined clusters, we recommend that users visualize the expression of canonical markers for different cell types (e.g., by using the `Seurat` function `FeaturePlot()`).

In addition to the UMAPs described above, SPEEDI also prints a heatmap showing cell type proportions for each sample:

```{r, echo=FALSE, fig.cap="Heatmap of cell type proportions."}
knitr::include_graphics(paste0(SPEEDI_variables$RNA_output_dir, "Final_RNA_Cell_Type_Proportion_Heatmap.png"))
```

## Step 9: Downstream Analyses

Now that we have a uniformly cell-type annotated and integrated dataset, we will use SPEEDI to perform two downstream analyses: differential expression analysis and functional module discovery. We use the `run_downstream_analyses_RNA()` function to run both analyses.

```{r downstream_analyses_rna, fig.show='hide'}
de_results <- run_downstream_analyses_RNA(sc_obj = sc_obj, reference_tissue = SPEEDI_variables$reference_tissue, 
                                      species = SPEEDI_variables$species, metadata_df = SPEEDI_variables$metadata_df, 
                                      output_dir = SPEEDI_variables$RNA_output_dir, log_flag = TRUE)
```

In our metadata data frame, we provided one metadata category ("disease") with each sample being assigned a value of "COVID" or "healthy". The `run_downstream_analyses_RNA()` wrapper function finds differentially expressed genes (DEGs) for each cell type (COVID vs. healthy) using SPEEDI's `RunDE_RNA()` function. SPEEDI first uses the `Seurat` function `FindMarkers()` to find DEGs on a single cell sample level (adjusted p-value threshold of 0.05, log fold change threshold of 0.1, and min.pct threshold of 0.1) and then uses `DESeq2` to further curate this list using pseudobulk level filtering (p-value threshold of 0.05 and log fold change threshold of 0.3). 

The final output is a table containing DEGs for each cell type:

```{r show_degs, fig.show='hide'}
DEGs_table <- utils::read.table(paste0(SPEEDI_variables$RNA_output_dir, "disease.DE.tsv"), header = TRUE, sep = "\t")
print(nrow(DEGs_table))
subset_DEGs_table <- rbind(DEGs_table[100:110,], DEGs_table[400:410,])
subset_DEGs_table$sc_pval_adj <- format(subset_DEGs_table$sc_pval_adj, digits = 5)
knitr::kable(subset_DEGs_table, "simple")
```

In total, there were 1905 DEGs found. We show a subset of the DEGs found for CD14 Mono and CD4 TCM cells.

Next, because our samples are human, the `run_downstream_analyses_RNA()` wrapper function will also run [functional module discovery](https://humanbase.readthedocs.io/en/latest/modules.html) (FMD) using SPEEDI's `run_fmd_wrapper()` function. As input, SPEEDI uses the cell-type specific DEGs found above. First, each list of cell-type DEGs is divided into separate lists of positive and negative fold change. For each separate list, if at least 20 genes are found in HumanBase, an FMD job is launched. Results are provided in a TSV file and include a HumanBase URL linking to the user's full results as well as a complete list of associated gene ontology (GO) enrichment terms.

Below, we show example output for CD16 monocytes that were upregulated in our COVID patients:

```{r show_fmd, fig.show='hide'}
FMD_file <- paste0(SPEEDI_variables$RNA_output_dir, "FMD_high_CD16_Mono_blood_disease.tsv")
FMD_URL <- readLines(FMD_file, n = 1)
FMD_table <- utils::read.table(FMD_file, header = TRUE, sep = "\t")
print(FMD_URL)

knitr::kable(head(FMD_table, 20), "simple")
```

If we go to the URL listed at the top of the table, we will see a network visualization of our results:

```{r, echo=FALSE, fig.cap="HumanBase network visualization for CD16 monocytes upregulated in COVID patients (background network of blood)."}
knitr::include_graphics(paste0(SPEEDI_variables$old_wd, "FMD_example.png"))
```

Note that HumanBase has multiple background networks for FMD. In our case, because our reference tissue was `PBMC_full`, SPEEDI automatically analyzed each list of DEGs using the `global` network as well as the `blood` network.

## Reminder: Use the SPEEDI Wrapper!

Above, we went through the SPEEDI pipeline step-by-step. However, the easiest way to run SPEEDI is with the `run_SPEEDI()` wrapper function. This function will complete all of the above steps automatically and will even save your `Seurat` object in `RNA_output_dir`. For our example, we would simply write:

```{r run_speedi_wrapper_function, eval = FALSE}
sc_obj <- run_SPEEDI(reference_tissue = reference_tissue, data_type = data_type, species = species, 
                     input_dir = input_dir, reference_dir = reference_dir, 
                     output_dir = output_dir, metadata_df = metadata_df)
```

# Other Types of Data Analyses

In addition to scRNA-seq analyses, SPEEDI can also run scATAC-seq, paired scRNA-seq / scATAC-seq, and same-cell multiome snRNA-seq / snRNA-seq analyses. To learn more, read the documentation for `run_SPEEDI()`!

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
